硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

**示例1:**

```
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

**示例2:**

```
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

​                



这个问题可以使用动态规划来解决。我们可以定义一个一维数组 `dp`，其中 `dp[i]` 表示凑成总金额 i 分的表示法的数量。

解题步骤：

1. 初始化 `dp` 数组，长度为 n+1，并将 `dp[0]` 初始化为 1，表示凑成总金额为 0 分的方式有 1 种（即什么都不选）。
2. 遍历硬币的面值，对于每个硬币的面值 coin，从 coin 开始遍历到 n，更新 `dp` 数组的值。
3. 对于每个金额 i，`dp[i]` 可以由两部分组成：
   - 不选当前硬币 coin，使用之前的 `dp[i]` 方案数，即 `dp[i] += dp[i - coin]`。
   - 选取当前硬币 coin，将当前硬币 coin 加入方案，即 `dp[i] += dp[i - coin]`。
4. 最后，`dp[n]` 就是凑成总金额 n 分的表示法数量。

由于结果可能会很大，需要将最终结果模上 1000000007，防止溢出。

现在，我们可以来实现 `waysToChange()` 方法：

```java
class Solution {
    public int waysToChange(int n) {
        int[] coins = {1, 5, 10, 25};
        int[] dp = new int[n + 1];
        dp[0] = 1;

        int mod = 1000000007;
        for (int coin : coins) {
            for (int i = coin; i <= n; i++) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }

        return dp[n];
    }
}
```

这个算法的时间复杂度是 O(n)。因为有一个嵌套循环遍历硬币面值，但硬币面值是固定的，因此复杂度实际上是 O(n)。空间复杂度是 O(n)，用于存储 `dp` 数组。由于结果需要模上 1000000007，因此运算过程中不会产生过大的数值。