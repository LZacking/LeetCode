给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。

返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。

**示例:**

```
输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3]
输出: [1, 3]
```

**示例:**

```
输入: array1 = [1, 2, 3], array2 = [4, 5, 6]
输出: []
```

**提示：**

- `1 <= array1.length, array2.length <= 100000`    





这个算法题要求在两个整数数组中各选择一个数，交换它们的位置，使得两个数组的元素和相等。如果有多个满足条件的交换组合，只需返回一个即可。如果无法找到满足条件的交换组合，则返回空数组。

让我们来分析一下解决这个问题的步骤：

1. 计算两个数组的元素和。
2. 如果两个数组的和之差不是偶数，说明无法通过交换得到相等的和，直接返回空数组。
3. 如果两个数组的和之差是偶数，我们的目标就是找到一对数，分别位于两个数组中，使得交换它们后，两个数组的和相等。
4. 我们可以通过遍历其中一个数组，对于数组1中的每个元素，我们可以计算在数组2中需要找到的目标值（即数组1总和与数组2总和之差的一半加上当前数组1元素的值）。
5. 在数组2中查找是否存在这个目标值，如果存在，则返回当前数组1元素和目标值。

以下是相应的Java代码实现，带有中文注释：

```java
class Solution {
    public int[] findSwapValues(int[] array1, int[] array2) {
        int sum1 = 0, sum2 = 0;
        
        // 计算两个数组的总和
        for (int num : array1) {
            sum1 += num;
        }
        for (int num : array2) {
            sum2 += num;
        }
        
        // 如果和之差不是偶数，无法得到相等的和，返回空数组
        if ((sum1 - sum2) % 2 != 0) {
            return new int[]{};
        }
        
        int targetDiff = (sum1 - sum2) / 2;
        
        // 在数组2中创建一个集合，方便快速查找
        Set<Integer> set = new HashSet<>();
        for (int num : array2) {
            set.add(num);
        }
        
        for (int num : array1) {
            // 计算在数组2中需要找的目标值
            int targetValueInArray2 = num - targetDiff;
            // 如果目标值在数组2中存在，返回结果
            if (set.contains(targetValueInArray2)) {
                return new int[]{num, targetValueInArray2};
            }
        }
        
        // 没有找到满足条件的交换组合，返回空数组
        return new int[]{};
    }
}
```

这个算法的时间复杂度主要取决于创建数组2的集合和遍历数组1，所以是O(n)级别的。