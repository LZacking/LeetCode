在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。

**示例:**

```
输入: [5, 3, 1, 2, 3]
输出: [5, 1, 3, 2, 3]
```

**提示：**

- `nums.length <= 10000`





分析：
这是一个将数组按峰与谷的交替顺序排序的问题。要求峰和谷交替出现，即相邻的元素交替变化，同时要求满足峰的条件：大于等于相邻整数，谷的条件：小于等于相邻整数。为了实现这个交替排序，我们可以采用一种贪心策略来实现。

解题步骤：
1. 首先，我们将数组排序，使得较大的元素在数组右侧，较小的元素在数组左侧。这样在排序后的数组中，大的元素会交替出现在偶数索引位置，小的元素会交替出现在奇数索引位置。
2. 接下来，我们可以定义两个指针，一个指向排序后数组的开头，一个指向数组中间位置（注意处理数组长度为偶数和奇数的情况）。
3. 然后，我们使用一个新的数组来保存结果，按照交替的顺序将排序后的较大元素和较小元素填充到新数组中。

根据以上步骤，我们可以实现 `wiggleSort()` 方法来排序数组。

```java
import java.util.Arrays;

class Solution {
    public void wiggleSort(int[] nums) {
        // 首先对数组排序
        Arrays.sort(nums);

        int n = nums.length;
        int[] result = new int[n];
        int left = (n - 1) / 2; // 左指针指向较小元素的位置
        int right = n - 1; // 右指针指向较大元素的位置

        // 交替填充较大元素和较小元素到新数组
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                result[i] = nums[left];
                left--;
            } else {
                result[i] = nums[right];
                right--;
            }
        }

        // 将新数组中的结果复制回原数组
        for (int i = 0; i < n; i++) {
            nums[i] = result[i];
        }
    }
}
```

这段代码实现了将数组按峰与谷的交替顺序排序的功能，运行效率较高，时间复杂度为 O(n log n)，其中 n 是数组的长度。