输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**示例 2：**

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```

 

**限制：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^6`



这个问题可以使用双指针法来解决，因为数组是递增排序的，可以利用这一特性来确定两个数的位置。以下是解题步骤：

1. 定义两个指针，一个指向数组开头（最小值），一个指向数组结尾（最大值）。

2. 在每一步迭代中，计算两个指针所指向的数的和。

3. 如果和等于目标值，返回两个指针所指向的数。

4. 如果和小于目标值，将左指针右移，使得和增大。

5. 如果和大于目标值，将右指针左移，使得和减小。

6. 重复步骤 2-5，直到找到一对数字的和等于目标值，或者左指针大于等于右指针时停止。

以下是用 Java 代码实现：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int sum = nums[left] + nums[right];
            
            if (sum == target) {
                return new int[]{nums[left], nums[right]};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        
        return new int[0]; // 没有找到符合条件的数字对
    }
}
```

这个算法的时间复杂度是 O(n)，其中 n 是数组的长度。因为只需要一次遍历就可以找到满足条件的数字对。代码中的中文注释解释了每个步骤的操作。