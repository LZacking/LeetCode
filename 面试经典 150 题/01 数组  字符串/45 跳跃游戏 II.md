给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`







问题分析：

这个问题是经典的贪心算法（Greedy Algorithm）问题，通常使用贪心算法来找到每一步的最优解，从而达到全局最优解。在这个问题中，我们需要找到到达数组最后一个位置的最小跳跃次数。

解题步骤：

1. 初始化变量 `maxPosition`，表示当前能够到达的最远位置。
2. 初始化变量 `end`，表示当前跳跃的边界，即当前步数能够达到的最远位置。
3. 初始化变量 `steps`，表示跳跃次数。
4. 遍历数组，对于每一个位置，更新 `maxPosition` 和 `end`。
5. 如果当前位置等于 `end`，表示已经到达当前步数的边界，需要进行下一步跳跃，将 `end` 更新为 `maxPosition`，并增加跳跃次数。
6. 最终返回跳跃次数。

代码实现：

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int maxPosition = 0; // 当前能够到达的最远位置
        int end = 0; // 当前跳跃的边界
        int steps = 0; // 跳跃次数

        for (int i = 0; i < n - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); // 更新当前能够到达的最远位置

            if (i == end) {
                end = maxPosition; // 更新跳跃边界为当前能够到达的最远位置
                steps++; // 增加跳跃次数
            }
        }

        return steps;
    }
}
```

这段代码使用贪心算法，每次选择能够使得下一步跳得最远的位置。在遍历数组的过程中，动态更新当前能够到达的最远位置 `maxPosition` 和跳跃边界 `end`。当遍历到当前步数的边界时，进行下一步跳跃，将边界更新为当前能够到达的最远位置，并增加跳跃次数。最终返回跳跃次数即为到达数组最后一个位置的最小跳跃次数。