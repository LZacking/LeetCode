给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`





### 问题分析

给定一个非负整数数组 `nums`，每个元素代表在该位置可以跳跃的最大长度。判断是否能够从数组的第一个下标跳跃到最后一个下标。

### 解题步骤

1. **贪心算法：** 从左到右遍历数组，维护一个变量 `maxReach`，表示当前能够到达的最远下标。遍历数组时，更新 `maxReach` 为当前下标和当前元素能够到达的最远下标之间的较大值。如果 `maxReach` 大于等于数组的最后一个下标，说明可以到达最后一个下标，返回 `true`；否则，返回 `false`。

### Java 代码

```java
class Solution {
    public boolean canJump(int[] nums) {
        // 特殊情况处理
        if (nums == null || nums.length == 0) {
            return false;
        }

        // 初始化最远可达下标
        int maxReach = 0;

        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            // 更新最远可达下标
            maxReach = Math.max(maxReach, i + nums[i]);

            // 如果最远可达下标大于等于数组的最后一个下标，说明可以到达
            if (maxReach >= nums.length - 1) {
                return true;
            }

            // 如果当前下标超过了最远可达下标，说明无法到达当前位置
            if (i >= maxReach) {
                return false;
            }
        }

        return false; // 不会执行到这一步，只是为了满足编译器要求
    }
}
```

这段代码使用了贪心算法的思想，时间复杂度为 O(n)，其中 n 是数组的长度。这种算法一遍遍历数组，不需要额外的空间，是一种高效的判断能否到达最后一个下标的方法。